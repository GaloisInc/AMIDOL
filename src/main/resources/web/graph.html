<!doctype html>
<meta charset="utf-8">
<head>
	<script type="text/javascript" src="jquery-3.3.1.min.js"></script>
	<script type="text/javascript" src="vis-4.21.0.min.js"></script>
	<script type="text/javascript" src="underscore-1.9.1.min.js"></script>
	<link rel="stylesheet" href="vis-4.21.0.min.css" type="text/css" />

	<script type="text/javascript" src="jquery.fancybox.min.js"></script>
	<link rel="stylesheet" href="jquery.fancybox.min.css" type="text/css" />

	<link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

	<link rel="stylesheet" href="normalize.css">
	<link rel="stylesheet" href="skeleton.css">

	<link rel="stylesheet" href="chartist.min.css" type="text/css" />
	<script type="text/javascript" src="chartist.min.js"></script>
	<script type="text/javascript" src="chartist-plugin-axistitle.min.js"></script>
	<script type="text/javascript" src="svg.js"></script>

<script type="text/javascript">

	var node_data_set, edge_data_set, network;
	var global_vars = { Example : 0 };
	var reward_vars = []// { key: "Example", opt1: "Susceptible", opt2: "Instant of Time", range: { start: 0, end: 100, step: 5 }} ];
	var chosen_backend = "scipy"


	function get(o, p) { return p.reduce((xs, x) => (xs && xs[x]) ? xs[x] : null, o) }

	function getOrElse(value, alternate) {
		if (typeof value != "undefined" && value != null) {
			return value
		} else {
			return alternate
		}
	}

	$.postJSON = function(url, data, callback) {
		return jQuery.ajax({
			'type': 'POST',
			'url': url,
			'contentType': 'application/json',
			'data': JSON.stringify(data),
			'dataType': 'json',
			'success': callback
		});
	};



	var journal = {
		past : [],
		future : [],

		// `apply`, `undo`, and `redo` manage the journals _and_ trigger effects through applyEventEffects
		apply: function(event) {
			this.past.push(event)
			this.future = []
			this.applyEventEffects(event)
		},

		undo : function() {
			if (this.past.length > 0) {
				var journal_event = this.past.pop()
				this.future.unshift(journal_event)
				this.applyEventEffects(this.invertEvent(journal_event))
			}
		},

		redo : function() {
			if (this.future.length > 0) {
				var journal_event = this.future.shift()
				this.past.push(journal_event)
				this.applyEventEffects(journal_event)
			}
		},


		// Purpose: cause UI side effects... and nothing else.
		// Always call last, after setting the relevant shared states.
		applyEventEffects : function(event) {
			switch (event.type) {
				case "add":
					node_data_set.add(event.nodes)
					edge_data_set.add(event.edges)
					break
				case "subtract":
					var node_ids_to_remove = _.pluck(event.nodes, "id")
					var edge_ids_to_remove = _.pluck(event.edges, "id")
					node_data_set.remove(node_ids_to_remove)
					edge_data_set.remove(edge_ids_to_remove)
					break
				case "move":
					_.mapObject(event.to, function(pos, nodeId){
						node_data_set.update({id: nodeId, x: pos.x, y: pos.y})
					})
					break
				case "renameEdge":
					edge_data_set.update({id: event.id, label: event.to})
					break
				case "renameNode":
					node_data_set.update({id: event.id, label: event.to})
					UI.render.localVars(event.id)
					break
				case "setProp":
					// { type: "setProp", id: 0, key: "", previous: "", updated: "" }
					var newParams = _.clone(get(node_data_set.get(event.id), ['props', 'parameters']))
					var newParamList = _.filter(newParams, (kv) => kv.name != event.key)
					if (event.updated !== null) {
						newParamList.push({ name: event.key, value: event.updated })
					}
					var newProps = _.clone(get(node_data_set.get(event.id), ['props']))
					newProps['parameters'] = newParamList
					node_data_set.update({ id: event.id, props: newProps })
					break
				case "setRewardVar":
					var new_rvs = _.filter(reward_vars, (v) => v.key != event.key)
					if (event.new != null) { new_rvs.push(event.new) }
					reward_vars = new_rvs
					UI.render.rewardVars()
					break
			//	case "setAllNodesEdges":
				default:
					console.log("Unknown event in applyEventEffects: " + JSON.stringify(event))
					break
			}
			UI.updateButtonStates()
		},

		invertEvent : function(initial_event) {
			var event = _.clone(initial_event)	// make a copy, return a new object
			switch (event.type) {
				case "add":
					event.type = "subtract"
					return event
				case "subtract":
					event.type = "add"
					return event
				case "move":
					var from = event.from
					event.from = event.to
					event.to = from
					return event
				case "renameEdge":
					var from = event.from
					event.from = event.to
					event.to = from
					return event
				case "renameNode":
					var from = event.from
					event.from = event.to
					event.to = from
					return event
				case "setProp":
					var previous = event.previous
					event.previous = event.updated
					event.updated = previous
					return event
				case "setRewardVar":
					var old = event.old
					event.old = event.new
					event.new = old
					return event
				default:
					console.log("Unknown event in invertEvent: " + JSON.stringify(event))
					return event
			}
		},

		logHistory : function() {
			console.log(
				JSON.stringify(
					[ _.map(journal.past, function(x){return x.type + ":" + _.map(x.nodes, function(y){return y.id})}),
						_.map(journal.future, function(x){return x.type + ":" + _.map(x.nodes, function(y){return y.id})}) ]
				)
			)
		}
	}

	var UI = {

		changeBackend: function(elem) {
			chosen_backend = $(elem).val()
		},

		render: {

			palette : function(items) {
				// Redraw dropdown
				$("#paletteChooser select option").remove();
				$("#paletteChooser select").append(
					_.map(_.keys(availablePalettes), function(k) { return $("<option>").html(k); })
				);
				$("#paletteChooser select").val(chosenPalette);

				// Redraww actual palette
				$("#palette .paletteItem").remove()
				$("#palette")
					.append(_.map(items, function(item){
						var p = paletteItems[item]
						return $("<img />")
							.attr({src: p.image, classname: p.className})
							.attr("onclick", "UI.selectPaletteNode(this)")
							.attr("ondblclick", "UI.paletteEditor.show('" + item + "')")
							.addClass("paletteItem")
							.addClass(p.type)
					}))
				if ($(".selected").length == 0) { $(".paletteItem").first().addClass("selected") }
			},

			localVars : function(id) {
				var vs = $("#localVars")
				vs.empty()
				if (_.isNull(id)) {
					vs.append("<p>Select a node to display its variables</p><h2>Global Variables:</h2>")
					_.mapObject(global_vars, (v, k) => vs.append(
						$("<div><label>"+k+'</label><input value="'+v+'" onblur=""></input></div>')
					))
					vs.append($("<button>").html("<strike>New</strike>").click((e) => UI.addGlobalVar() ))
				} else {
					var thisNode = node_data_set.get(id)
					vs.append('<p onclick="network.selectNodes([]);UI.render.localVars(null)">⇐ back to global variables</p><h2>' + getOrElse(thisNode.label, "(no_name)") + "</h2>")
					var vars = getOrElse(get(thisNode, ['props', 'parameters']), [])
					vs.append(_.map(vars, function(v){
						return $("<div><label>"+v.name+'</label><input value="'+v.value+'" onblur="UI.propBlur({id: \''+id+'\'}, \''+v.name+'\', this.value)"></input></div>')
					}))
					vs.append($("<button>").html("<strike>New</strike>").click((e) => UI.addLocalVar() ))
				}
			},

			rewardVars : function() {
				var rvs = $("#rewardVars")
				rvs.empty()
				rvs.append("<h2>Measures:</h2>")
				var nodeNames = _.filter(_.map(node_data_set.get(), function(n) {
					if (get(paletteItems, [n.props.className, 'type']) == "noun") { return [n.id, n.label] } else { [] }
				}), (a) => ! _.isEmpty(a))
				var rv_names = ["Instant of Time", "Interval of Time", "Time Avg. Interval", "Steady State"]


				// reward_vars = _.map(reward_vars, function(r){
				//	if ( ! _.isEmpty(nodeNames) && ! _.contains(nodeNames, r.opt1)) {
				//		r.opt1 = nodeNames[0][1]
				//	}
				//	return r
				// })

				rvs.append(_.map(reward_vars, function(r){
					return $("<div>").attr({class: "rv_element", rv_key: r.key}).change(
						(e) => UI.updateRewardVar(r.key)
					).append([
						$("<h3>").attr({class: "key"}).html(r.key),
						$("<div>").append(
							$("<select>").attr({class: "opt1"}).append(
								_.map(nodeNames, function(n) {
									var opt = $("<option>").attr('value', n[1]).html(n[1])
									if (r.opt1 == n[1]) {
										opt.attr('selected','selected')
									}
									return opt
								})
							)
						),
						$("<h4>").html("Range"),
						$("<div>").append(
							$("<select>").attr({class: "opt2"}).append(
								_.map(rv_names, function(n, idx) {
									var opt = $("<option>").attr({'value': n}).html(n)
									if (idx != 0) { opt.attr('disabled', 'disabled') }
									return opt
								})
							),
							$("<div>").append(
								$("<div>").attr({class: "range_param"}).append(
									$("<label>").html("Start"),
									$("<input>").attr({class: "range_start", value: r.range.start, 'size': 5})
								),
								$("<div>").attr({class: "range_param"}).append(
									$("<label>").html("Until"),
									$("<input>").attr({class: "range_end", value: r.range.end, 'size': 5})
								),
								$("<div>").attr({class: "range_param"}).append(
									$("<label>").html("Step"),
									$("<input>").attr({class: "range_step", value: r.range.step, 'size': 5})
								)
							)
						),
						$("<button>").html("Delete").css({clear: "both"}).click(function(e){
							UI.removeRewardVar(r.key)
						})
					])
				}))
				rvs.append($("<button>").html("New").click((e) => UI.addRewardVar() ))
			},

			fancyCharts : function(chartsData) {
				$.fancybox.destroy()
				var chartIdPrefix = "chart-"
				var charts = _.map(chartsData, function(i, idx) {
					return $("<div>").attr({id: chartIdPrefix + idx, class: "resultChart"})
				})
				$("#results").append(charts)
				$.fancybox.open(charts, {
					helpers : {
						title : { type : 'inside' }
					},
					loop : true,
					afterClose: function() { $("#results").empty() },
					beforeShow: function() {
						// Creating the Chartist objects are in the `beforeShow` function because they were not rendering properly when fancybox changed slides. (all elements in the graph were rendered at a single point)
						_.map(chartsData, function(singleChartData, idx){
							var pluginOpts = {
								chartPadding: { top: 20, right: 0, bottom: 20, left: 0 },
								plugins: [ Chartist.plugins.ctAxisTitle({
									axisX: {
										axisTitle: singleChartData.title,
										axisClass: "ct-axis-title",
										offset: { x: 0, y: 40 },
										textAnchor: "middle"
									},
									axisY: {}
								})]
							}
							new Chartist.Line("#" + chartIdPrefix + idx, singleChartData, pluginOpts)
						})
					}
				})
			},

			iconRedraw : function() {
				_.forEach(node_data_set.getIds(), function(id) {
					var className = node_data_set.get(id).props.className
					node_data_set.update({ id: id, image: paletteItems[className].image })
				})
			},

			network : function() {
				var data = { "nodes" : [], "edges" : [] }
				var options = {
					physics: false,
					nodes: {
						shape: "image"
					},
					edges: {
						smooth: false,
						color: { color: "black" },
						arrows: "to"
					},
					manipulation: {
						initiallyActive: true,
						addNode: function(node, callback){
							node.label = prompt("Name your new node:")
							var isUnused = _.find(node_data_set.get(), (n) => n.label == node.label) === undefined
							if (node.label != null && isUnused) {
								node.image = $("#palette img.selected").attr("src")
								var className = $("#palette img.selected").attr("classname")
								var node = UI.makeNode(node, className)
								journal.apply( { "type": "add", "nodes": [node], "edges": [] } )
							} else {
								if (! isUnused) { alert("That name is already used.") }
							}
						},
						addEdge: function(edge, callback){
							// edge.label = prompt("Edge label:")
							var fromClass = get(node_data_set.get(edge.from), ['props', 'className'])
							var toClass = get(node_data_set.get(edge.to), ['props', 'className'])
							var fromType = fromClass && get(paletteItems, [fromClass, 'type'])
							var toType = toClass && get(paletteItems, [toClass, 'type'])
							if (fromType !== toType) {
								journal.apply( { "type": "add", "nodes": [], "edges": [edge] } )
							} else {
								alert("Cannot draw edges between two " + fromType + "s.")
							}
						},
						editEdge: false,
						// editNode: function(node, callback) {
						//	var props = getOrElse(node.props, [])
						//	UI.render.localVars(node.id, node.label, props)
						//	callback() // returns the editing bar to its normal state
						// },
						deleteNode: function(dataIds, callback) {
							journal.apply( {
								"type": "subtract",
								"nodes": node_data_set.get(dataIds.nodes),
								"edges": edge_data_set.get(dataIds.edges)
							} )
						},
						deleteEdge: function(dataIds, callback) {
							journal.apply( {
								"type": "subtract",
								"nodes": node_data_set.get(dataIds.nodes),
								"edges": edge_data_set.get(dataIds.edges)
							} )
						}
					}
				}

				node_data_set = new vis.DataSet(data.nodes)
				edge_data_set = new vis.DataSet(data.edges)

				var container = document.getElementById('graph')
				var network_data = { "nodes" : node_data_set, "edges" : edge_data_set }
				network = new vis.Network(container, network_data, options)

				network.on("oncontext", UI.networkRightClick)
				network.on("doubleClick", function(e){
					// Renameing nodes and edges:
					if (_.size(e.nodes) == 1) {
						var newName = prompt("New node name:")
						var isUnused = _.find(node_data_set.get(), (n) => n.label == newName) === undefined
						if (newName !== null && isUnused) {
							UI.renameNode(e.nodes[0], newName)
						} else {
							if (! isUnused) { alert("That name is already used.") }
						}
					}
					// else { if (_.size(e.edges) == 1) {
					//	var newName = prompt("New edge name:")
					//	if (newName !== null) {
					//		UI.renameEdge(e.edges[0], newName)
					//	}
					// }}
				})
				// network.on("oncontext", function(){})
				network.on("selectNode", function(data){
					if (data.nodes.length == 1) {
						UI.render.localVars(data.nodes[0])
						$("#palette img.selected").removeClass("selected");
						$("#palette img[classname='" + node_data_set.get(data.nodes[0]).props.className + "']").addClass("selected");
					}
				})
				network.on("deselectNode", function(data){
					UI.render.localVars(null)
				})
				// network.on("selectEdge", function(data){console.log("selectEdge"); console.log(data)})
				// network.on("deselectEdge", function(data){console.log("deselectEdge"); console.log(data)})
				network.on("hold", function(e){
					console.log(e)
				})
				network.on("dragStart", function(e){
					var selectedNodes = network.getSelectedNodes()
					if ( ! _.isEmpty(selectedNodes)) {
						UI.movingNodes = network.getPositions(selectedNodes)
					}
				})
				network.on("dragEnd", function(e){
					if (UI.movingNodes != null) {
						var from = UI.movingNodes
						var to = network.getPositions(_.keys(UI.movingNodes))
						UI.movingNodes = null
						journal.past.push({ "type" : "move", "from": from, "to": to })
					}
				})
				// $("#graph").on("mousemove", null)	// Cannot use network 'dragging' event?
			}
		},

		paletteEditor: {
			show: function(toEditName) {
				// Update the palette dropdown before showing
				$("#palette-element-selector").empty()
				$("#palette-element-selector").append($("<option>").attr({ value: "" }).text("None"))
				$("#palette-element-selector").append(_.map(
					availablePalettes[chosenPalette],
					function(key) { return $("<option>").attr({ value: key }).text(key); }
				))
				if (toEditName) {
					$("#palette-element-selector").val(toEditName);
					UI.paletteEditor.loadTemplate(toEditName);
				}

				$("#paletteEditor").show()
			},

			hide: function() {
				$("#paletteEditor").hide()
				$("#palette-element-name").val("")
				$("#palette-element-type").val("noun")
				$("#palette-element-class").val("")
				$("#palette-element-icon").val("")
				$("#palette-element-color").val("")
				$("#palette-element-shared").val("")
				$("#palette-element-model").val("")
			},

			loadTemplate: function(toEditName) {
				var toEdit = paletteItems[toEditName]
				console.log(toEdit)
				if (toEdit) {
					UI.paletteEditor.updateSaveButton(toEdit.className);
					$("#palette-element-name").val(toEdit.className)
					$("#palette-element-type").val(toEdit.type)
					$("#palette-element-icon").val(toEdit.icon)
					$("#palette-element-color").val(toEdit.color)
					$("#palette-element-shared").val(toEdit.sharedStates.join(", "))
					$("#palette-element-model").val(JSON.stringify(toEdit.backingModel, null, 2))
				}
			},

			updateSaveButton: function(nameValue) {
				if (paletteItems.hasOwnProperty(nameValue)) {
					$("#save-palette-element").text("Update existing element");
					$("#remove-palette-element").show();
				} else {
					$("#save-palette-element").text("Save new element");
					$("#remove-palette-element").hide();
				}
			},

			deletePaletteElement: function() {
				var name = $("#palette-element-name").val()
				$.post("/appstate/palette/remove", { name: name })
					.done(palette.update(function () {

						// Re-render and clean up
						UI.render.palette(availablePalettes[chosenPalette])
						UI.render.iconRedraw()

						$("#paletteEditor").hide()
						$("#palette-element-name").val("")
						$("#palette-element-type").val("noun")
						$("#palette-element-class").val("")
						$("#palette-element-icon").val("")
						$("#palette-element-color").val("")
						$("#palette-element-shared").val("")
						$("#palette-element-model").val("")
						UI.paletteEditor.updateSaveButton("")
					}));
			},

			submitPaletteElement: function() {
				var paletteEditor = $("#paletteEditor")

				// Get values from all fields
				// TODO: validate the data we get
				// TODO: support _all_ fields (including parameters)
				var name = $("#palette-element-name").val()
				if (name == "") {
					alert("Invalid empty palette element name");
					return;
				}
				var type = $("#palette-element-type").val()
				var icon = $("#palette-element-icon").val()
				var color = $("#palette-element-color").val()
				var shared = _.map(
					$("#palette-element-shared").val().split(","),
					function (st) { return st.trim() }
				)
				try {
					var model = JSON.parse($("#palette-element-model").val())
				} catch (e) {
					alert("Malformed JSON description of IR model!\n\n(" + e.message + ")");
					return;
				}

				refillSvg(icon, color).done(function(image) {
					// Set the palette element
					var paletteElement = {
						className: name,
						type: type,
						icon: icon,
						color: color,
						image: image,
						sharedStates: shared,
						backingModel: model,
					}

					$.post("/appstate/palette/put", { name: name, palette: JSON.stringify(paletteElement) })
						.fail(function (err) {
							alert("Failed to register new palette element.\n\n(" + err.responseText + ")");
						})
						.done(function () {

							// Detect new!
							if (!paletteItems[name]) {
								availablePalettes[chosenPalette].push(name)
							}
							paletteItems[name] = paletteElement

							// Re-render and clean up
							UI.render.palette(availablePalettes[chosenPalette])
							UI.render.iconRedraw()

							$("#paletteEditor").hide()
							$("#palette-element-name").val("")
							$("#palette-element-type").val("noun")
							$("#palette-element-class").val("")
							$("#palette-element-icon").val("")
							$("#palette-element-color").val("")
							$("#palette-element-shared").val("")
							$("#palette-element-model").val("")
							UI.paletteEditor.updateSaveButton("")
						});
				});
			}
		},

		// Remove all nodes in the network drawn (but they are still accessible through history)
		clearNetwork : function(reason) {
			if (_.isEmpty(node_data_set.get()) || confirm(reason)) {
				journal.past = []
				journal.applyEventEffects( { type: "subtract", nodes: node_data_set.get(), edges: edge_data_set.get() } )
				return true
			} else {
				return false
			}
		},

		choosePalette: function(elem) {
			chosenPalette = $(elem).val()
			if (UI.clearNetwork("Changing palettes will clear the drawing canvas.")) {
				UI.render.palette(availablePalettes[chosenPalette])
			}
		},

		makeNode : function(node, className) {
			if ( ! node.hasOwnProperty("id")) {
				function randomUuid() {
					return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
						var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8)
						return v.toString(16)
					})
				}
				node.id = randomUuid()
			}
			var paletteItem = paletteItems[className]
			var parameters = _.map(_.pairs(paletteItem.backingModel.constants), function(e) {
				return {
					name: e[0],
					value: e[1].toString()
				}
			})
			node.props = {
				"className":	_.clone(paletteItem.className),
				"parameters":  _.clone(parameters)
			}
			node.image = paletteItem.image
			return node
		},

		// This is a terrible hack!
		propBlur: function(idObj, key, val){
			UI.setProp(idObj.id, key, val)
		},

		updateRewardVar : function(rvKey) {
			parent = $(".rv_element[rv_key='"+rvKey+"']")
			var new_rv = {
				key: parent.find(".key").html(),
				opt1: parent.find(".opt1").val(),
				opt2: parent.find(".opt2").val(),
				range: {
					start: parent.find(".range_start").val(),
					end: parent.find(".range_end").val(),
					step: parent.find(".range_step").val()
				}
			}
			var old_rv = _.clone(_.find(reward_vars, (v) => v.key == new_rv.key))
			var event = { type: "setRewardVar", key: new_rv.key, old: old_rv, new: new_rv }
			journal.apply( event )
		},

		addRewardVar : function() {
			var name = prompt("Name your new reward variable:")
			if (name != undefined && ! _.contains(_.pluck(reward_vars, "id"), name )) {
				var new_rv = {
					key: name,
					opt1: getOrElse(_.find(node_data_set.get(), (n) => get(paletteItems, [n.props.className, 'type']) == "noun"), {label: ""}).label,
					opt2: "Instant of Time",
					range: { start: 0, end: 100, step: 5 }
				}
				var event = { type: "setRewardVar", key: new_rv.key, old: null, new: new_rv }
				journal.apply(event)
			}
		},

		removeRewardVar : function(key) {
			if (key != undefined && ! _.contains(_.pluck(reward_vars, "id"), key )) {
				var old_rv = _.find(reward_vars, (v) => v.key == key)
				var event = { type: "setRewardVar", key: key, old: old_rv, new: null }
				journal.apply(event)
			}
		},

		addGlobalVar : function() {
			alert("Not supported yet.")
		},

		addLocalVar : function() {
			alert("Not supported yet.")
		},

		setProp: function(id, key, value) {
			var paramList = get(node_data_set.get(id), ['props', 'parameters'])
			var previous = get(_.find(paramList, (p) => p.name === key), ['value'])
			journal.apply(
				{ type: "setProp", id: id, key: key, previous: previous, updated: value }
			)
		},

		renameEdge : function(edgeId, newName) {
			var existing = edge_data_set.get(edgeId)
			var event = {type: "renameEdge", id: edgeId, from: existing.label, to: newName}
			journal.apply(event)
		},

		renameNode : function(nodeId, newName) {
			var existing = node_data_set.get(nodeId)
			var event = {type: "renameNode", id: nodeId, from: existing.label, to: newName}
			journal.apply(event)
		},

		updateButtonStates : function() {
			if (_.isEmpty(journal.past)) {
				$("#undo_button").addClass("disabled")
			} else {
				$("#undo_button").removeClass("disabled")
			}
			if (_.isEmpty(journal.future)) {
				$("#redo_button").addClass("disabled")
			} else {
				$("#redo_button").removeClass("disabled")
			}
			var selectedNodes = network.getSelectedNodes()
			if (selectedNodes.length == 1) {
				UI.render.localVars(selectedNodes[0])
			} else {
				UI.render.localVars(null)
			}
			UI.render.rewardVars()
		},

		selectPaletteNode : function(elem) {
			$("#palette img").removeClass("selected")
			$(elem).addClass("selected")
		},

		networkRightClick : function(context) {
			context.event.preventDefault()
		},

		movingNodes : null, // or:	{ nodeId1: {x: xValue, y: yValue}, … }

		download : function() {
			var data = {
				journal: journal.past,
				reward_vars: reward_vars,
				global_vars: global_vars,
				chosen_palette: chosenPalette,
			}
			var blob = new Blob([JSON.stringify(data)], {type: "application/json"})
			var a = document.createElement('a')
			a.download = "model.json"
			a.href = URL.createObjectURL(blob)
			a.target = "_blank"
			a.click()
		},

		upload : function(event) {
			var files = event.target.files
			_.map(files, function(f){
				if (f.type === "application/json" &&
						UI.clearNetwork("Loading up a model will clear the drawing canvas.")) {
					journal.future = []
					var reader = new FileReader()
					reader.onload = function(e) {
						var data = JSON.parse(e.target.result)
						journal.future = journal.future.concat(data.journal)
						global_vars = data.global_vars;
						reward_vars = data.reward_vars;
						chosenPalette = data.chosen_palette;
						UI.updateButtonStates()
					}
					reader.onloadend = function(e) {
						do { $("#redo_button").click() }
						while ( ! $("#redo_button").hasClass("disabled"))
						UI.render.palette(availablePalettes[chosenPalette])
						UI.render.rewardVars()
						UI.render.localVars()
						UI.render.iconRedraw()
					}
					reader.readAsText(f)
				}
			})
		},

		uploadJuliaSrc : function(event) {
			var file = event.target.files[0];
			if (file && UI.clearNetwork("Loading up a Julia model will clear the drawing canvas.")) {
				var reader = new FileReader();
				reader.onload = function (e) {
						var payload = {
							name: "julia_model",
							juliaSourceCode: e.target.result
						};
						$.post("/appstate/loadJuliaModel", payload, function(res) {
						var nodes = _.values(res.nodes)
						var links = _.values(res.links)
						journal.future.push({
							type: "add",
							nodes: _.map(nodes, function (node) {
								node.image = "images/unknown.png";
								return node;
							}),
							edges: links
						});
						availablePalettes["julia_model"] = _.map(nodes, function (n) {
							return n.props.className;
						});
						chosenPalette = "julia_model";
						global_vars = []
						reward_vars = []
						palette.update(function () {
							$("#redo_button").click()
							UI.updateButtonStates()
							UI.render.rewardVars()
							UI.render.localVars()
							UI.render.iconRedraw()
							UI.render.palette(availablePalettes[chosenPalette])
							network.setOptions({ physics: true })
							setTimeout(function() {
								network.setOptions({ physics: false })
							}, 1000)
						})
					});
				};
				reader.readAsText(file);
			}
		}
	}

	var IR = {

		chartCount: 0,
		chartDataAcc: [],

		submit : function(){
			if (_.isEmpty(reward_vars) || !_.isEmpty(_.find(reward_vars, (rv) => rv.opt1 == ""))) { return alert("Cannot execute a model with no reward variables. Please create at least one reward variable.")}

			$.fancybox.open($("<img>").attr({src: "images/spinner.gif"}))

			IR.submitGraph(function(data, status, jqXHR) {
				IR.chartCount = reward_vars.length
				IR.chartDataAcc = []

				_.map(reward_vars, function(rv) {
					var simParams = {
						"initialTime": parseFloat(rv.range.start),
						"finalTime": parseFloat(rv.range.end),
						"stepSize": parseFloat(rv.range.step),
						"savePlot": null
					}
					if (_.range(simParams.initialTime, simParams.finalTime, simParams.stepSize).length > 10000) {
						alert("Sampling the range you defined will require more memory than this system can spare right now.")
						$.fancybox.destroy()
						return false
					}
					IR.execute.backend.integrate(simParams, function(data, status, jqXHR) {
						IR.chartDataAcc.push({
							title: rv.opt1,
							labels: data.times,
							series: [
								data.variables[rv.opt1]
							]
						})
						if (IR.chartCount == IR.chartDataAcc.length){
							UI.render.fancyCharts( IR.chartDataAcc )
							IR.chartDataAcc = []
							IR.chartCount = 0
						}
					})
				})
			})
		},

		submitGraph : function(onSuccessFunc){
			$.post("/appstate/uiModel", IR.getData(), onSuccessFunc)
		},

		execute : {
			backend : {
				integrate : function(simParams, onSuccessFunc) {
					$.postJSON("/backends/"+chosen_backend+"/integrate", simParams, onSuccessFunc)
				}
			}
		},

		getData : function(){
			return {
				graph: JSON.stringify({
					nodes : node_data_set.getDataSet()._data,
					links : edge_data_set.getDataSet()._data
				}) /*,
				globalVariables: JSON.stringify(global_vars) */
			}
		}
	}

	var palette = {
		update : function(onComplete) {
			$.post("/appstate/palette/list", {})
				.then(function (data) {
					paletteItems = { }
					var remaining = data.length - 1;
					return $.when.apply($, _.map(data, function(item) {
						return refillSvg(item.icon, item.color).then(function (image) {
							item.image = image
							paletteItems[item.className] = item
						})
					}))
				})
				.done(function () {
					availablePalettes = _.mapObject(availablePalettes, function (pal) {
						return _.filter(
							pal,
							function(name) { return paletteItems.hasOwnProperty(name); }
						)
					})
					if (onComplete) onComplete()
				})
		}
	}


	var paletteItems = { }			// loaded from server dynamically
	var chosenPalette = "SIR"
	var availablePalettes = {
		"SIR" : [
				"population",
				"patient",
				"infect",
				"cure",
		],
		"SIRS-VD": [
				"population_vital_dynamics",
				"patient_vital_dynamics",
				"infect",
				"cure",
				"time",
		],
		"predator_prey" : [
				"predator",
				"prey",
				"hunting",
		],
	}


	$(function(){ palette.update(function () {
		document.getElementById('choose-upload').addEventListener('change', UI.upload, false)
		document.getElementById('choose-julia-upload').addEventListener('change', UI.uploadJuliaSrc, false)

		var startingPalette =  availablePalettes[chosenPalette]

		UI.render.network()

		UI.render.palette(startingPalette)
		UI.render.localVars(null)
		UI.render.rewardVars()
		UI.updateButtonStates()

	}) })

</script>

<style type="text/css">
	html, body, #graph {
		padding: 0px;
		margin: 0px;
		height: 100%;
		width: 100%;
		overflow: hidden;
	}
	#header {
		text-align: center;
	}
	#graph {
		float:left;
		width: 75%;
		/*border: 5px solid gray;*/
	}
	#palette img {
		margin: 5px;
		padding: 5px;
		height: 50px;
		border: 5px solid white;
	}
	.vis-manipulation {
		outline: 1px solid gray;
		width: 99.9% !important; /* Ugly UI hack! */
	}
	.vis-close {
		display: none !important;
	}
	.verb {
		fill: gray;
	}
	#palette img.selected {
		border-color: lightblue;
	}
	#palette img.right, #palette input.right {
		margin-top: 1em;
		height: 25px;
	}
	#palette .right{
		float: right;
	}
	#exec_button, #upload_julia_button {
		margin: 22px 0px 22px 22px;
	}
	#exec_chooser {
		margin: 22px 0px 22px 0px;
	}
	#paletteChooser{
		margin: 1.5em 1.5em 0em 1.5em;
		float: left;
	}
	#palette img.disabled {
		opacity: 0.25;
	}
	#variables {
		height: 100%;
		width: 25%;
		border-color: green;
		float: right;
	}
	#localVars {
		width: 100%;
		height: 45%;
		outline: 1px solid gray;
		overflow: scroll;
		padding: 1em;
		box-sizing: border-box;
	}
	#localVars p {
		/*text-decoration: underline;*/
	}
	#rewardVars {
		width: 100%;
		height: 45%;
		outline: 1px solid gray;
		overflow: scroll;
		padding: 1em;
		box-sizing: border-box;
	}
	#rewardVars .rv_element:not(:last-child) {
		border-bottom: 1px solid #000;
		margin-bottom: 1em;
	}
	.range_param {
		display: inline-block;
		padding: 1em;
	}
	.opt2 {
		margin: 0px;
	}
	h2 {
		font-size: 1.75em;
	}
	h3 {
		font-size: 1.5em;
	}
	h4 {
		font-size: 1.1em;
	}
	button {
		background-color: white;
	}
	.resultChart {
		width: 80%;
		height: 80%
	}

	#paletteEditor {
		position: absolute;
		left: 40px;
		right: 40px;
		top: 40px;
		max-height: calc(100% - 80px - 70px);
		background-color: lightgray;
		border: 1px solid gray;
		border-radius: 15px;
		padding: 35px;
		z-index: 1;
		overflow-y: scroll;
	}


</style></head>
<body>
	<div id="results" style="display: none;"></div>
	<div id="paletteEditor" style="display: none;">
		<h3>Palette element editor</h3>

		Start from (or edit) an existing element:
		<select id="palette-element-selector"
						name="template"
						style='width: 100%'
						onchange="UI.paletteEditor.loadTemplate(this.value)">
		</select>
		<br/>

		<table style='width: 100%'>
			<tr>
				<td>Name:</td>
				<td>
					<input
						id="palette-element-name"
						type="text"
						name="name"
						style='width: 100%'
						onchange="UI.paletteEditor.updateSaveButton(this.value)"
						onkeyup="UI.paletteEditor.updateSaveButton(this.value)"/>
				</td>
			</tr>

			<tr>
				<td>Type:</td>
				<td>
					<select id="palette-element-type" name="type" style='width: 100%'>
						<option value="noun">Noun</option>
						<option value="verb">Verb</option>
					</select>
				</td>
			</tr>

			<tr>
				<td>Icon:</td>
				<td>
					<select id="palette-element-icon" name="icon name" style='width: calc(100% - 70px)'>
						<option value="images/birth.svg">Birth</option>
						<option value="images/breeding.svg">Breeding</option>
						<option value="images/cure.svg">Cure</option>
						<option value="images/death.svg">Death</option>
						<option value="images/hunting.svg">Hunting</option>
						<option value="images/patient.svg">Patient</option>
						<option value="images/person.svg">Person</option>
						<option value="images/predator.svg">Predator</option>
						<option value="images/prey.svg">Prey</option>
						<option value="images/time.svg">Time</option>
						<option value="images/virus.svg">Virus</option>
					</select>
					<input id="palette-element-color" type="color" name="icon color" style='width: 60px'/>
				</td>
			</tr>

			<tr>
				<td>Shared states (enter comma-delimited):</td>
				<td><input id="palette-element-shared" type="text" name="shared states" style='width: 100%'/></td>
			</tr>

			<tr>
				<td>Backend model (enter JSON):</td>
				<td><textarea id="palette-element-model" type="text" name="backend model" style='width: 100%; resize: vertical'></textarea></td>
			</tr>
		</table>

		<center>
			<button onclick="UI.paletteEditor.hide()">
				Cancel
			</button>
			<button id="save-palette-element" onclick="UI.paletteEditor.submitPaletteElement()">
				Save new element
			</button>
			<button id="remove-palette-element" onclick="UI.paletteEditor.deletePaletteElement()" style="display:none">
				Remove element
			</button>
		</center>
	</div>
	<div id="palette">
		<div id="paletteChooser">
			<select onchange="UI.choosePalette(this)"></select>
			<button onclick="UI.paletteEditor.show()">Edit</button>
		</div>
		<select id="exec_chooser" class="right" onchange="UI.changeBackend(this)">
			<option value="scipy">SciPy</option>
			<option value="pysces">PySCeS</option>
			<option value="julia">Julia</option>
		</select>
		<button id="exec_button" class="right" onclick="IR.submit()">Execute</button>
		<button id="upload_julia_button" class="right" onclick="document.getElementById('choose-julia-upload').click()">Load Julia code</button>
		<img id="redo_button" class="right" src="images/redo.png" onclick="journal.redo()" />
		<img id="undo_button" class="right" src="images/undo.png" onclick="journal.undo()" />
		<img id="upload" class="right" src="images/upload.png" onclick="document.getElementById('choose-upload').click()" />
		<img id="download" class="right" src="images/download.png" onclick="UI.download()" />
		<input type="file" id="choose-upload" name="files[]" style="display: none;" multiple />
		<input type="file" class="right" id="choose-julia-upload" name="files[]" style="display: none;" />
	</div>
	<div id="graph"></div>
	<div id="variables" class="compensate-for-scrollbar">
		<div id="localVars" class="compensate-for-scrollbar"></div>
		<div id="rewardVars" class="compensate-for-scrollbar"></div>
	</div>
</body>
