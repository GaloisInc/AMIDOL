package amidol.backends

import scala.util._
import amidol._
import spray.json._
import scala.sys.process._
import java.nio.file.Files
import java.nio.file.Paths
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport
import scala.concurrent.{ExecutionContext, Future}

object PySCeS extends ContinuousInitialValue {
 
  val name: String = "PySCeS"
  val backendDescription: String = ""
  
  // TODO: revisit this when we have discrete events
  def applicable(model: Model): Boolean = true

  // TODO: do we want proper AST manipulation
  type Python = String
  type PySCeS = String

  override def run(
    model: Model,
    constants: Map[String, Double],
    boundary:  Map[String, Double],
    inputs: Inputs
  )(implicit
    ec: ExecutionContext
  ): Future[Try[Outputs]] = Future {

    // PySCeS doesn't like unicode =.=
    val renamer = Renamer.filterAscii()

    for {
      constants <- Try(constants.map { case (k,v) => math.Expr(k).flatMap(_.asVariable).get -> v })
      boundary  <- Try(boundary.map { case (k,v) => math.Expr(k).flatMap(_.asVariable).get -> v })

      // Pretty-printing
      reactions: List[PySCeS] = model.events.toList.map {
        case (_, Conserved(edgeId, src, tgt, expr)) =>
          val srcVar = renamer.getOrInsert(model.states(src).stateVariable)
          val tgtVar = renamer.getOrInsert(model.states(tgt).stateVariable)
          s"""|reaction_${edgeId.id.toString.replace('-','n')}:
              |     ${srcVar.prettyPrint()} > ${tgtVar.prettyPrint()}
              |     ${expr.renameVariables(renamer).prettyPrint()}
              |""".stripMargin

        case (_, Unconserved(edgeId, src, tgt, exprOut, exprIn)) =>
          val srcVar = renamer.getOrInsert(model.states(src).stateVariable)
          val tgtVar = renamer.getOrInsert(model.states(tgt).stateVariable)
          s"""|reactionsource_${edgeId.id.toString.replace('-','n')}:
              |     $$pool > ${tgtVar.prettyPrint()}
              |     ${exprIn.renameVariables(renamer).prettyPrint()}
              |
              |reactionsink_${edgeId.id.toString.replace('-','n')}:
              |     ${srcVar.prettyPrint()} > $$pool
              |     ${exprOut.renameVariables(renamer).prettyPrint()}
              |""".stripMargin

        case (_, Source(edgeId, tgt, exprIn)) =>
          val tgtVar = renamer.getOrInsert(model.states(tgt).stateVariable)
          s"""|reaction_${edgeId.id.toString.replace('-','n')}:
              |     $$pool > ${tgtVar.prettyPrint()}
              |     ${exprIn.renameVariables(renamer).prettyPrint()}
              |""".stripMargin

        case (_, Sink(edgeId, src, exprOut)) =>
          val srcVar = renamer.getOrInsert(model.states(src).stateVariable)
          s"""|reaction_${edgeId.id.toString.replace('-','n')}:
              |     ${srcVar.prettyPrint()} > $$pool
              |     ${exprOut.renameVariables(renamer).prettyPrint()}
              |""".stripMargin

      }
      
      initialAndConstants: List[PySCeS] =
        boundary.toList.map(vd => s"${renamer.getOrInsert(vd._1).prettyPrint()} = ${vd._2}") ++
        constants.toList.map(vd => s"${renamer.getOrInsert(vd._1).prettyPrint()} = ${vd._2}")

      // PySCeS code
      pyscesCode: PySCeS = s"""
        |Modelname: tmp_model
        |Description: Autogenerated tmp_model
        |
        |Species_In_Conc: False
        |Output_In_Conc: False
        |
        |# Reactions
        |${reactions.mkString("\n")}
        |
        |# Parameter values
        |${initialAndConstants.mkString("\n")}
        |""".stripMargin
      _ <- Try(Files.write(Paths.get("tmp_model.psc"), pyscesCode.getBytes))

      // Python code 
      currentDir <- Try(new java.io.File(".").getCanonicalPath()) // TODO: I think we need some escaping...
      pythonCode: Python = s"""
        |import pysces
        |import json
        |import numpy as np
        |
        |# This is so that we can call "json.dumps" on Numpy arrays
        |class NumpyEncoder(json.JSONEncoder):
        |    def default(self, obj):
        |        if isinstance(obj, np.ndarray):
        |            return obj.tolist()
        |        return json.JSONEncoder.default(self, obj)
        |
        |mod = pysces.model('tmp_model', dir='${currentDir}')
        |mod.sim_start  = ${inputs.initialTime}
        |mod.sim_end    = ${inputs.finalTime - 1}
        |mod.sim_points = ${(inputs.finalTime - inputs.initialTime) / inputs.stepSize}
        |mod.Simulate()
        |
        |Sdata, Slabels = mod.data_sim.getSpecies(lbls=True)
        |output = { lbl: arr for lbl, arr in zip(Slabels, Sdata.transpose()) }
        |output_str = json.dumps(output, cls=NumpyEncoder)
        |
        |output_file = open('${currentDir}/tmp_output.json', mode='w')
        |output_file.write(output_str)
        |output_file.close()
        |""".stripMargin

      // Run the code
      outputMap <- Try {
        Files.write(Paths.get("tmp_script.py"), pythonCode.getBytes)
        println("Running `python tmp_script.py`...")
        "python tmp_script.py" ! ProcessLogger(_ => ()) // blocks until script returns
        scala.io.Source.fromFile("tmp_output.json").mkString
      }

      // Parse the output back out
      mapOut <- Try(outputMap.parseJson.convertTo[Map[String,Seq[Double]]])
      timeRange <- Try(mapOut("Time"))

    } yield Outputs(
      variables = (mapOut - "Time").map { case (k,v) => renamer.reverseGet(math.Variable(Symbol(k))).get.s.name -> v },
      times = timeRange
    )
  }
}
