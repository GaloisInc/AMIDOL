\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdftitle={AMIDOL IR},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\title{AMIDOL IR}
\date{}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{3}
\tableofcontents
}
\subsection{Formal Definition}\label{formal-definition}

Formally, the IR is a 5-tuple, \[(S, E, L, \Phi, \Lambda, \Delta)\]
where: * \[S\] is a finite set of state variables
\[\{s_0, s_1, \ldots, s_{n-1}\}\] that take on values in \[\mathbb{N}\].
* \[E\] is a finite set of events \[\{e_0, e_1, \ldots, e_{m-1}\}\] that
may occur in the model. * \[L: S \mid E \rightarrow \mathbb{N}\] is the
event and state variable labeling function that maps elements of \[S\]
and \[E\] into the original ontology. *
\[\Phi: E \times N_0 \times N_1 \times \ldots \times N_{n-1} \rightarrow \{0, 1\}\]
is the event enabling predicate. *
\[\Lambda: E \times N_0 \times N_1 \times \ldots \times N_{n-1} \rightarrow (0, \infty)\]
is the transition rate specification. *
\[\Delta: E \times N_0 \times N_1 \times \ldots \times N_{n-1} \rightarrow N_0 \times N_1 \times \ldots \times N_{n-1}\]
is the state variable transition function specification.

Informally the IR represents a model using a universal and
Turing-complete mathematical language using a formalism based on
Generalized Stochastic Petri-nets with inhibitor arcs. Instead of
inhibitor arcs, we utilize the more intuitive and compact method of
allowing events to have input predicates \[\Phi\] which can be evaluated
to determine if an event is enabled, and output predicates \[\Delta\]
which define the side effects of event firing.

Intuitively, the \emph{marking} of a model in the IR given as
\[N_0 \times N_1 \times \ldots \times N_{n-1}\] is the set values of
each state variable. We typically do not represent the entire marking
when giving the definition of enabling conditions (input predicates),
transition rates associated with an event, or state variable transition
function (output predicates), and instead only indicate the markings on
which an given input predicate depends, and those state variables whose
values change when an event fires due to the output predicate, omitting
the ``don't care'' values.

\subsubsection{State Variables}\label{state-variables}

State variables are defined in the IR as objects which have a name, a
set of semantic labels, a state variable type (such as int or float),
and an initial value given as an expression.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"state_variable"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"string"}\OtherTok{]}\FunctionTok{,}
    \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[}\StringTok{"string"}\OtherTok{]}\FunctionTok{,}
    \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"sv_type"}\FunctionTok{,}
    \DataTypeTok{"initial_value"}\FunctionTok{:} \StringTok{"expression"}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

Intuitively, the set of state variables in a model define the current
state. While state variables are defined as taking on values in
\[\mathbb{N}\] in the formal definition, this does not restrict them
from representing real numbers to arbitrary precision in modern computer
hardware. In practice, they are implemented as integers, and floating
point numbers by solvers.

\subsubsection{Events}\label{events}

Events are defined in the IR as objects which have a name, a set of
semantic labels, a rate given as an expression, and an input predicate
and output predicate, defined either as objects, or undefined. In the
cases where the input predicate is undefined, it is interpreted as being
always true. In the case where the output predicate is undefined, the
event is interpreted as having no effect on the state of the model when
it fires.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"event"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"string"}\OtherTok{]}\FunctionTok{,}
    \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[}\StringTok{"string"}\OtherTok{]}\FunctionTok{,}
    \DataTypeTok{"rate"}\FunctionTok{:} \StringTok{"expression"}\FunctionTok{,}
    \DataTypeTok{"input_predicate"}\FunctionTok{:} \FunctionTok{\{\},}
    \DataTypeTok{"output_predicate"}\FunctionTok{:} \FunctionTok{\{\},}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

Events can be interpreted in two ways: discrete and continuous. In both
cases events define the ways in which a model can change state by
altering the value of state variables. In the discrete case, events fire
at discrete times defined by their rates, changing the value of the
model at those times as defined by their output predicates. In the
continuous case, events define flow relations which alter the state in
proportion to their output predicates scaled by their rates.

Currently in AMIDOL, all rates are considered exponential. AMIDOL can be
extended at a later date to account for general distributions.

\paragraph{Input Predicates}\label{input-predicates}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"input_predicate"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"enabling_condition"}\FunctionTok{:} \StringTok{"boolean_expression"}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

\paragraph{Output Predicates}\label{output-predicates}

The transition function is specified as a partially defined state change
vector

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"output_predicate"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"transition_function"}\FunctionTok{:} \OtherTok{[}\FunctionTok{\{}\DataTypeTok{"sv_name"}\FunctionTok{:} \StringTok{"string"}\FunctionTok{,} \DataTypeTok{"function"}\FunctionTok{:} \StringTok{"expression"}\FunctionTok{\}}\OtherTok{]}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

Output predicates define the state change vector associated with event
firing through partial definition as a list of state variable names,
followed by an expression \[e\] indicating their change when the event
is fired under the discrete interpretation of events. Given an event
with rate \[\mu\] the continuous interpretation of event firing utilizes
a scaled version of this expression given by \[\mu \cdot e\].

\[ \frac{dS}{dt} = -\frac{\beta IS}{N} \]

\[ \frac{dI}{dt} = \frac{\beta IS}{N} - \gamma I \]

\[ \frac{dR}{dt} = \gamma I \]

For example, the ``infect'' event of an SIR model given above would have
rate \[\beta \frac{SI}{N}\], and the partial state transition function
{[}\{``S'': -1\}, \{``I'': 1\}{]}.

\subsubsection{Names of State Variables and
Events}\label{names-of-state-variables-and-events}

In order to support composition via the operations of state sharing, and
event sharing, the AMIDOL IR represents names of state variables and
events as lists of strings. The strings in this list must be unique to
the individual state variable or event, or the model is invalid and an
exception should be raised. For example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"state_variable"}\FunctionTok{:} \FunctionTok{\{} \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"S"}\OtherTok{]}\FunctionTok{,} \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[]}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"int"}\FunctionTok{,}
    \DataTypeTok{"initial_value"}\FunctionTok{:} \StringTok{"0"}\FunctionTok{\}\}}\ErrorTok{,}
\FunctionTok{\{} \DataTypeTok{"state_variable"}\FunctionTok{:} \FunctionTok{\{} \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"I"}\OtherTok{,} \StringTok{"Infected"}\OtherTok{]}\FunctionTok{,} \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[]}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"int"}\FunctionTok{,}
    \DataTypeTok{"initial_value"}\FunctionTok{:} \StringTok{"0"}\FunctionTok{\}\}}
\end{Highlighting}
\end{Shaded}

Is a valid model, the strings in each name list are unique. But the
following example should have an exception raised:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"state_variable"}\FunctionTok{:} \FunctionTok{\{} \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"S"}\OtherTok{]}\FunctionTok{,} \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[]}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"int"}\FunctionTok{,}
    \DataTypeTok{"initial_value"}\FunctionTok{:} \StringTok{"0"}\FunctionTok{\}\}}\ErrorTok{,}
\FunctionTok{\{} \DataTypeTok{"state_variable"}\FunctionTok{:} \FunctionTok{\{} \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"I"}\OtherTok{,} \StringTok{"S"}\OtherTok{]}\FunctionTok{,} \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[]}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"int"}\FunctionTok{,}
    \DataTypeTok{"initial_value"}\FunctionTok{:} \StringTok{"0"}\FunctionTok{\}\}}
\end{Highlighting}
\end{Shaded}

as the string ``S'' is shared by the name lists of both state variables.
Names are lists to allow for easy name resolution when composing two
models. Given the following Models:

\textbf{Model A}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"state_variable"}\FunctionTok{:} \FunctionTok{\{} \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"S"}\OtherTok{]}\FunctionTok{,} \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[]}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"int"}\FunctionTok{,}
    \DataTypeTok{"initial_value"}\FunctionTok{:} \StringTok{"0"}\FunctionTok{\}\}}
\end{Highlighting}
\end{Shaded}

\textbf{Model B}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"state_variable"}\FunctionTok{:} \FunctionTok{\{} \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"Susceptible"}\OtherTok{]}\FunctionTok{,} \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[]}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"int"}\FunctionTok{,}
    \DataTypeTok{"initial_value"}\FunctionTok{:} \StringTok{"0"}\FunctionTok{\}\}}
\end{Highlighting}
\end{Shaded}

Composing A and B on \texttt{{[}"S",\ "Susceptible"{]}} results in the
model:

\textbf{Model AcB}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"state_variable"}\FunctionTok{:} \FunctionTok{\{} \DataTypeTok{"name"}\FunctionTok{:} \OtherTok{[}\StringTok{"S"}\OtherTok{,} \StringTok{"Susceptible"}\OtherTok{]}\FunctionTok{,} \DataTypeTok{"labels"}\FunctionTok{:} \OtherTok{[]}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"int"}\FunctionTok{,}
    \DataTypeTok{"initial_value"}\FunctionTok{:} \StringTok{"0"}\FunctionTok{\}\}}
\end{Highlighting}
\end{Shaded}

Any events in Model A which referred to ``S'' are treated as if they
refer to the new shared state variable with name
\texttt{{[}"S",\ "Susceptible"{]}}.

\subsubsection{Labels}\label{labels}

Elements of the IR have labels associated with them, used to propagate
domain knowledge from the formulation in a VDSOL to the mathematical
elements of the IR.

\subsubsection{Constants}\label{constants}

Constants in the IR allow the definition of identifiers which refer to
literal values, mostly useful for setting model wide scaling factors,
initial conditions, etc.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"constant"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"name"}\FunctionTok{:} \StringTok{"string"}\FunctionTok{,}
    \DataTypeTok{"value"}\FunctionTok{:} \StringTok{"literal"}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Expressions}\label{expressions}

Expressions in AMIDOL are defined by a simple syntax over state variable
names, constant names, and literal constants.

\begin{verbatim}
expression ::= term "+" expression | term "-" expression |
               term
term       ::= "(" expression ")" | term "*" expression | term "/" expression |
               atom
atom       ::= identifier | literal
identifier ::= sv_name | constant_name
literal    ::= integer | float
\end{verbatim}

\paragraph{Boolean Expressions}\label{boolean-expressions}

Input predicates utilize boolean expressions, which are defined by the
following syntax which builds on the syntax given above.

\begin{verbatim}
boolean_expression ::= "(" boolean_expression ")" | "NOT" boolean_expression |
                       boolean_expression "AND" boolean_expression |
                       boolean_expression "OR" boolean_expression | boolean_term
boolean_term ::= expression relation expression | "TRUE" | "FALSE"
\end{verbatim}

\subsection{Reward Variables}\label{reward-variables}

The AMIDOL IR allows the specifications of reward variables as a partial
definition of a model, and the composition of these reward variables
with other models to define measures of interest which can be solved by
the executable translation of a total model in the IR. Given a model
\[M = (S, E, L, \Phi, \Lambda, \Delta)\] we define two basic types of
rewards structures, rewards over state variable values (rate rewards),
and rewards over events (impulse rewards).

\subsubsection{Rate Rewards}\label{rate-rewards}

A rate reward is formally defined as a function
\[\mathcal{R}: P(S, \mathbb{N}) \rightarrow \mathbb{R}\] where
\[q \in P(S, \mathbb{N})\] is the reward accumulated when for each
\[(s,n) \in q\] the marking of the state variable \[s\] is \[n\].
Informally a rate reward variable \[x\] accumulates a defined reward
whenever a subset of the state variables take on prescribed values.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"rate_reward"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"name"}\FunctionTok{:} \StringTok{"string"}\FunctionTok{,}
    \DataTypeTok{"sv_name"}\FunctionTok{:} \StringTok{"sv_name string"}\FunctionTok{,}
    \DataTypeTok{"reward"}\FunctionTok{:} \StringTok{"expression"}\FunctionTok{,}
    \DataTypeTok{"temporal_type"}\FunctionTok{:} \StringTok{"instant_of_time"}\ErrorTok{|}\StringTok{"interval_of_time"}\ErrorTok{|}\StringTok{"time_averaged_interval_of_time"}\ErrorTok{|}\StringTok{"steady_state"}\FunctionTok{,}
    \DataTypeTok{"temporal_domain"}\FunctionTok{:} \OtherTok{[}\StringTok{"float"}\OtherTok{]}
  \FunctionTok{\}}  
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

The IR definition of a rate reward associates the identifier of a single
state variable with a temporal type and time domain, and a reward
expression. The reward variable begins with an initial value of zero and
functions as an accumulator, accumulating value equal to the evaluation
of the reward expression as specified by the temporal type and time
domain.

\subsubsection{Impulse Rewards}\label{impulse-rewards}

An impulse reward is formally defined as a function
\[\mathcal{I}: E \rightarrow \mathbb{R}\] where
\[e \in E, \mathcal{I}_e\] is the reward for the completion of \[e\].
Informally an impulse reward variable \[x\] accumulates a defined reward
whenever the event \[e\] fires.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"impulse_reward"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"name"}\FunctionTok{:} \StringTok{"string"}\FunctionTok{,}
    \DataTypeTok{"ev_name"}\FunctionTok{:} \StringTok{"ev_name string"}\FunctionTok{,}
    \DataTypeTok{"reward"}\FunctionTok{:} \StringTok{"expression"}\FunctionTok{,}
    \DataTypeTok{"temporal_type"}\FunctionTok{:} \StringTok{"instant_of_time"}\ErrorTok{|}\StringTok{"interval_of_time"}\ErrorTok{|}\StringTok{"time_averaged_interval_of_time"}\ErrorTok{|}\StringTok{"steady_state"}\FunctionTok{,}
    \DataTypeTok{"temporal_domain"}\FunctionTok{:} \OtherTok{[}\StringTok{"float"}\OtherTok{]}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

The IR definition of an impulse reward associates the identifier of a
single event with a temporal type and time domain, and a reward
expression. The reward variable begins with an initial value of zero and
functions as an accumulator, accumulating value equal to the evaluation
of the reward expression as specified by the temporal type and time
domain.

\subsubsection{Temporal Characteristics of Reward
Variables}\label{temporal-characteristics-of-reward-variables}

Both rate and impulse reward variables measure the behavior of a model
\[M\] with respect to time. As such, a reward variable \[\theta\] is
declared as either an instant-of-time variable, an interval-of-time
variable, a time-averaged interval-of-time variable, or a steady state
variable. An instant of time variable \[\Theta_t\] is defined as:

\[\theta_t = \sum_{\nu \in P(S, \mathbb{N})} \mathcal{R}(\nu) \cdot \mathcal{I}^{\nu}_t + \sum_{e \in E} \mathcal{I}(e) \cdot I_t^e\\]

Intuitively a rate reward declared as an instant-of-time variable can be
used to measure the value of a state variable precisely at time \[t\],
and an impulse reward declared as an instant-of-time variable can be
used to measure whether a given event fired at precisely time \[t\].
While the latter is not a particularly useful measure (as the
probability of an event with a firing time drawn from a continuous
distribution at time \[t\] is 0) it is defined primarily for closure
reasons, as well as extensions to discrete general distributions.

An interval-of-time variable intuitively accumulates reward over some
fixed interval of time \[[t, t+1]\]. Given such a variable
\[\theta_{[t, t+1]}\] we formally define interval-of-time variables as:

\[\theta_{[t,t+1]} = \sum_{\nu \in P(S, \mathbb{N})} \mathcal{R}(\nu) \cdot \mathcal{J}^{\nu}_{[t, t+1]} + \sum_{e \in E} \mathcal{I}(e)N^e_{[t,t+1]}\]

where

\begin{itemize}
\tightlist
\item
  \[J^{\nu}_{[t,t+1]}\] is a random variable which represents the total
  time the model spent in a marking such that for each
  \[(s, n) \in \nu\], the state variable \[s\] has a value of \[n\]
  during the period \[[t, t+1]\].
\item
  \[I^e_{t\rightarrow\infty}\] is a random variable which represents the
  number of times an event \[e\] has fired during the period
  \[[t, t+1]\].
\end{itemize}

Time-averaged interval of time variables quantify accumulated reward
over some interval of time. Such a variable \[\theta'_{[t,t+1]}\] is
defined formally as:

\[\theta'_{[t,t+1]} = \frac{\theta_{[t,t+1]}}{l}\]

Steady state reward variables are realized by testing for initial
transients, and calculating an instant of time variable after a model
has reached a stable steady state with high confidence.

\paragraph{Practical considerations of temporal
domains}\label{practical-considerations-of-temporal-domains}

Given a rate or impulse reward with temporal type and domain:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"temporal_type"}\FunctionTok{:} \StringTok{"instant_of_time"}\ErrorTok{|}\StringTok{"interval_of_time"}\ErrorTok{|}\StringTok{"time_averaged_interval_of_time"}\ErrorTok{|}\StringTok{"steady_state"}\FunctionTok{,}
\DataTypeTok{"temporal_domain"}\FunctionTok{:} \OtherTok{[}\StringTok{"float"}\OtherTok{]}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

The temporal domain is interpreted as follows:

\begin{itemize}
\tightlist
\item
  \textbf{Instant of time} - a list of times to sample the reward. For a
  list \[[t_0, \ldots, t_{n-1}]\] we create \[n\] separate instant of
  time reward variables which all accumulate exactly one observation at
  the specified time.
\item
  \textbf{Interval of time} and \textbf{Time averaged interval of time}
  - the list should include exactly three values, \[[t_0, t_{n-1}, s]\].
  A single accumulator is created which accumulates rewards
  \[\frac{t_{n-1} - t_0}{s}\] times at points
  \[t_0, (t_0 + s), (t_0 + 2s), \ldots\].
\item
  \textbf{Steady state} - the list should include exactly one value,
  which is an estimate of when the system reaches steady state. A single
  accumulator is created to store the appropriate reward.
\end{itemize}

\subsubsection{Composed Rewards}\label{composed-rewards}

Composed rewards are defined with rewards that are a special type of
expression, a reward variable expression.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"composed_reward"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"name"}\FunctionTok{:} \StringTok{"string"}\FunctionTok{,}
    \DataTypeTok{"reward"}\FunctionTok{:} \StringTok{"rv_expression"}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Reward Expressions}\label{reward-expressions}

Reward variable expressions differ from standard expressions in the
AMIDOL IR in their identifier term, which can only refer to names of
other reward variables.

\begin{verbatim}
rv_expression ::= rv_term "+" rv_expression | rv_term "-" rv_expression |
                  rv_term
rv_term       ::= "(" rv_expression ")" | rv_term "*" rv_expression |
                  rv_term "/" rv_expression |rv_atom
rv_atom       ::= rv_identifier | literal
rv_identifier ::= rate_reward_name | impulse_reward_name | composed_reward_name | constant_name
literal       ::= integer | float
\end{verbatim}

Composed rewards allow us to construct a set of arbitrary measures on
the set of impulse and rate rewards. Composed rewards need not be solved
for during execution of a model, but can be computed after solving a
model for the impulse and rate rewards contained in the reward
expression for a composed reward variable.

\subsection{Practical Considerations}\label{practical-considerations}

\subsubsection{Partially Defined Models}\label{partially-defined-models}

A model is considered partially defined, and thus unexecutable if: * It
contains expressions which refer to \texttt{identifier}s or
\texttt{rv\_identifier}s which are undefined. * If it contains no state
variables.

A model without a reward variable is fully defined, but trivially so as
it has a null solution.

\subsection{Transformations}\label{transformations}

\subsubsection{Composition}\label{composition}

\subsection{Turing Completeness}\label{turing-completeness}

\subsection{Compactness of
Representation}\label{compactness-of-representation}

\subsection{Examples}\label{examples}

\end{document}
